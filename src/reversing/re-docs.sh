#!/bin/bash
# Reverse Engineering Documentation Generator - Generate docs from code
# Extracts and formats documentation from codebases

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${HOME}/.claude/logs/re-docs.log"
OUTPUT_DIR="${HOME}/.claude/reverse-engineering"

mkdir -p "$(dirname "$LOG_FILE")"
mkdir -p "$OUTPUT_DIR"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

# ============================================================================
# Code Analysis Functions
# ============================================================================

detect_language() {
    local file="$1"

    case "$file" in
        *.ts|*.tsx) echo "typescript" ;;
        *.js|*.jsx) echo "javascript" ;;
        *.py) echo "python" ;;
        *.go) echo "go" ;;
        *.java) echo "java" ;;
        *.rb) echo "ruby" ;;
        *.php) echo "php" ;;
        *.rs) echo "rust" ;;
        *.c|*.h) echo "c" ;;
        *.cpp|*.hpp) echo "cpp" ;;
        *) echo "unknown" ;;
    esac
}

extract_functions() {
    local file="$1"
    local lang=$(detect_language "$file")

    case "$lang" in
        typescript|javascript)
            grep -E '^\s*(export\s+)?(async\s+)?function\s+\w+|^\s*(export\s+)?(const|let|var)\s+\w+\s*=\s*(async\s+)?\(.*\)\s*=>' "$file" | \
                sed -E 's/^\s*(export\s+)?(async\s+)?function\s+//;s/^\s*(export\s+)?(const|let|var)\s+\w+\s*=\s*(async\s+)?//;s/\s*\(.*\)\s*=>//' | \
                head -20
            ;;
        python)
            grep -E '^\s*def\s+\w+' "$file" | sed 's/^\s*def //' | head -20
            ;;
        go)
            grep -E '^\s*func\s+\w+' "$file" | sed 's/^\s*func //' | head -20
            ;;
        *)
            echo "Language $lang not yet supported for function extraction"
            ;;
    esac
}

extract_classes() {
    local file="$1"
    local lang=$(detect_language "$file")

    case "$lang" in
        typescript|javascript)
            grep -E '^\s*(export\s+)?(class|interface|type)\s+\w+' "$file" | \
                sed -E 's/^\s*(export\s+)?//' | head -20
            ;;
        python)
            grep -E '^\s*class\s+\w+' "$file" | sed 's/^\s*class //' | head -20
            ;;
        java)
            grep -E '^\s*(public|private|protected)?\s*class\s+\w+' "$file" | \
                sed -E 's/^\s*(public|private|protected)?\s*class //' | head -20
            ;;
        *)
            echo "Language $lang not yet supported for class extraction"
            ;;
    esac
}

extract_imports() {
    local file="$1"
    local lang=$(detect_language "$file")

    case "$lang" in
        typescript|javascript)
            grep -E '^\s*import\s+|^const.*require\(|export.*from' "$file" | head -20
            ;;
        python)
            grep -E '^\s*import\s+|^from\s+\w+\s+import' "$file" | head -20
            ;;
        go)
            grep -E '^\s*import\s+\(|^\s*"github\.com' "$file" | head -20
            ;;
        *)
            echo "Language $lang not yet supported for import extraction"
            ;;
    esac
}

# ============================================================================
# Documentation Generators
# ============================================================================

generate_file_documentation() {
    local file="$1"
    local output_format="${2:-markdown}"

    log "Generating documentation for: $file"

    local lang=$(detect_language "$file")
    local functions=$(extract_functions "$file")
    local classes=$(extract_classes "$file")
    local imports=$(extract_imports "$file")

    local filename=$(basename "$file")
    local rel_path="${file#$(pwd)/}"

    if [[ "$output_format" == "markdown" ]]; then
        cat <<EOF
# Documentation: $filename

**Language**: $lang
**Path**: \`$rel_path\`

## Overview
[Auto-generated documentation for this file]

## Imports
\`\`\`$lang
$imports
\`\`\`

## Classes/Types
\`\`\`$lang
$classes
\`\`\`

## Functions
\`\`\`$lang
$functions
\`\`\`

---
*Generated by re-docs.sh on $(date '+%Y-%m-%d %H:%M:%S')*
EOF
    else
        if command -v jq &>/dev/null; then
            jq -n \
                --arg filename "$filename" \
                --arg path "$rel_path" \
                --arg lang "$lang" \
                --arg imports "$imports" \
                --arg classes "$classes" \
                --arg functions "$functions" \
                --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '{
                    filename: $filename,
                    path: $path,
                    language: $lang,
                    imports: $imports,
                    classes: $classes,
                    functions: $functions,
                    generatedAt: $timestamp
                }'
        else
            echo "JSON format requires jq"
        fi
    fi
}

generate_project_documentation() {
    local project_dir="${1:-.}"
    local output_format="${2:-markdown}"

    log "Generating project documentation for: $project_dir"

    local project_name=$(basename "$(cd "$project_dir" && pwd)")
    local files=$(find "$project_dir" -type f \( -name "*.ts" -o -name "*.js" -o -name "*.py" -o -name "*.go" -o -name "*.java" \) 2>/dev/null | head -50)
    local total_files=$(echo "$files" | wc -l | tr -d ' ')

    local languages=()
    while IFS= read -r file; do
        [[ -f "$file" ]] || continue
        local lang=$(detect_language "$file")
        if [[ ! " ${languages[@]} " =~ " $lang " ]]; then
            languages+=("$lang")
        fi
    done <<< "$files"

    if [[ "$output_format" == "markdown" ]]; then
        cat <<EOF
# Project Documentation: $project_name

**Generated**: $(date '+%Y-%m-%d %H:%M:%S')
**Files Analyzed**: $total_files

## Overview
[Auto-generated project documentation]

## Languages Used
${languages[*]}

## File Structure
\`\`\`
$(cd "$project_dir" && find . -type f \( -name "*.ts" -o -name "*.js" -o -name "*.py" -o -name "*.go" -o -name "*.java" \) | head -50)
\`\`\`

## Statistics
- **Total Files**: $total_files
- **Languages**: ${#languages[@]}

## Key Directories
$(cd "$project_dir" && find . -maxdepth 2 -type d | grep -v "^\.$" | head -20)

---
*Generated by re-docs.sh*
EOF
    else
        if command -v jq &>/dev/null; then
            jq -n \
                --arg name "$project_name" \
                --argjson languages "$(echo "${languages[@]}" | jq -Rs 'split(" ") | unique | map(select(length > 0))' 2>/dev/null || echo '[]')" \
                --argjson file_count "$total_files" \
                --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '{
                    projectName: $name,
                    languages: $languages,
                    fileCount: $file_count,
                    generatedAt: $timestamp
                }'
        else
            echo "JSON format requires jq"
        fi
    fi
}

generate_api_documentation() {
    local project_dir="${1:-.}"
    local output_format="${2:-markdown}"

    log "Generating API documentation for: $project_dir"

    local api_files=$(find "$project_dir" -type f \( -name "*route*.ts" -o -name "*route*.js" -o -name "*api*.ts" -o -name "*api*.js" -o -name "*controller*.ts" -o -name "*controller*.js" \) 2>/dev/null | head -20)

    if [[ "$output_format" == "markdown" ]]; then
        cat <<EOF
# API Documentation

**Generated**: $(date '+%Y-%m-%d %H:%M:%S')

## Overview
[Auto-generated API documentation]

## Endpoints

EOF

        while IFS= read -r file; do
            [[ -f "$file" ]] || continue
            echo "### $(basename "$file")"
            echo ""
            echo '```typescript'
            extract_functions "$file"
            echo '```'
            echo ""
        done <<< "$api_files"

        cat <<EOF
---
*Generated by re-docs.sh*
EOF
    else
        if command -v jq &>/dev/null; then
            local endpoints="[]"
            while IFS= read -r file; do
                [[ -f "$file" ]] || continue
                local funcs=$(extract_functions "$file")
                endpoints=$(echo "$endpoints" | jq --arg file "$(basename "$file")" --arg funcs "$funcs" '. + [{"file": $file, "functions": ($funcs | split("\n") | map(select(length > 0)))}]' 2>/dev/null || echo '[]')
            done <<< "$api_files"

            jq -n \
                --argjson endpoints "$endpoints" \
                --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '{
                    type: "API Documentation",
                    endpoints: $endpoints,
                    generatedAt: $timestamp
                }'
        else
            echo "JSON format requires jq"
        fi
    fi
}

# ============================================================================
# Main Generator
# ============================================================================

generate() {
    local doc_type="$1"
    shift
    local args=("$@")

    log "Generating $doc_type documentation with args: ${args[*]}"

    local output=""
    local output_file="${OUTPUT_DIR}/docs-${doc_type}-$(date +%s).md"

    case "$doc_type" in
        file)
            output=$(generate_file_documentation "${args[0]:-}" "${args[1]:-markdown}")
            ;;

        project)
            output=$(generate_project_documentation "${args[0]:-.}" "${args[1]:-markdown}")
            ;;

        api)
            output=$(generate_api_documentation "${args[0]:-.}" "${args[1]:-markdown}")
            ;;

        *)
            echo "Unknown documentation type: $doc_type"
            echo "Available: file, project, api"
            return 1
            ;;
    esac

    # Save to file
    echo "$output" > "$output_file"
    log "Documentation saved to: $output_file"

    # Output to stdout
    echo "$output"
    echo ""
    echo "---"
    echo "Documentation saved to: $output_file"
}

# ============================================================================
# CLI Interface
# ============================================================================

case "${1:-help}" in
    file)
        generate "file" "${2:-}" "${3:-}"
        ;;

    project)
        generate "project" "$2"
        ;;

    api)
        generate "api" "$2" "$3"
        ;;

    help|*)
        cat <<EOF
Reverse Engineering Documentation Generator - Generate docs from code

Usage: $0 <type> [args...]

Documentation Types:
  file <path> [format]    - Generate documentation for a single file
  project <dir> [format]   - Generate project-level documentation
  api <dir> [format]       - Generate API documentation

Formats:
  markdown (default) - Human-readable markdown
  json              - Structured JSON data

Examples:
  $0 file ./src/auth.ts
  $0 file ./src/api.ts json
  $0 project ./src
  $0 api ./src/routes

Output:
  - Documentation printed to stdout
  - Saved to: ~/.claude/reverse-engineering/docs-*.md

Supported Languages:
  - TypeScript/JavaScript
  - Python
  - Go
  - Java
  - C/C++
  - Ruby
  - PHP
  - Rust

Extracted Information:
  - Functions and methods
  - Classes and interfaces
  - Imports and dependencies
  - File structure
  - Project statistics
EOF
        ;;
esac
